
New UNICAST design
==================
(see UNICAST.txt for the old design)

Author: Bela Ban
Version: $Id: UNICAST.new.txt,v 1.1.2.2 2009/04/01 09:04:25 belaban Exp $

Motivation
----------

UNICAST has issues when one end of the connnection unilaterally closes the connection and discards the state in
the connection table.

Example: we have a conn between A and B. There's a partition such that A sees {A,B} but B sees only {B}.
B will clear its connection table for A on reception of the view, whereas A will keep it.

Now the partition heals and A and B can communicate again.

Assuming A's next seqno to B is #25 (and #7 for receiving messages from B),
B will store the message because it expects #1 from A (new connection). As a matter of fact, B will store *and not
deliver* all subsequent messages from A !

The reverse direction is also bad: B will send #1 to A, but A expects #7, so A will discard the message. The first 6
messages from B are discarded at A !


Goals
-----

#1 Handle the above scenarios

#2 Handle the scenario where a member communicates with a non-member

#3 Handle the scenario where a member talks to a non existing (or previous) member. Get rid of
   ENABLE_UNICASTS_TO and age out connections to non existing members after some time (JGRP-942)

#4 Should be usable without group communication ('Unicast JGroups')


Design
------

As example we have a unicast connection between A and B. A is the sender and B the receiver:

             A <-------------------------------------------------> B

             B:entry.seqno=#25                                     A:entry.seqno=#7
                     recv_win=#7                                           recv_win=#25
                     send-conn-id=322649                                   send-conn-id=101200
                     recv-conn-id=101200                                   recv-conn-id=322649

A has an entry in the connection table for B, and B has an entry for A. Each connection has a connection ID (conn-id).
Each entry also has a seqno which is the highest seqno sent to the peer so far, and a recv_win which has the highest
seqno received from the peer so far. For example, A's next message to B will be #25, and the next seqno expected
from B is #7.



A sends a message to B:
- If the entry for B is null, or the seqno=0:
  - Set first=true in the UnicastHeader

B receives a message from A:
- If first=true:
  - If entry or entry.recv_win for B is null --> create a new entry.recv_win with msg.seqno
  - Else:
    - If msg.seqno == entry.recv_win.next_expected_seqno: NOP
    - Else --> create new entry.recv_win with msg.seqno





Issues
------
- How do we handle retransmissions of the first message (first=true) ? We *cannot* create a new entry.recv_win, or
else we trash already received msgs ! Use a UUID (as connection-ID) instead of first=true ? Maybe the system time
is sufficient ? After all, the ID only has to be unique between A and B !

