
New UNICAST design
==================
(see UNICAST.txt for the old design)

Author: Bela Ban
Version: $Id: UNICAST.new.txt,v 1.1.2.4 2009/04/01 10:16:07 belaban Exp $

Motivation
----------

UNICAST has issues when one end of the connnection unilaterally closes the connection and discards the state in
the connection table.

Example: we have a conn between A and B. There's a partition such that A sees {A,B} but B sees only {B}.
B will clear its connection table for A on reception of the view, whereas A will keep it.

Now the partition heals and A and B can communicate again.

Assuming A's next seqno to B is #25 (and #7 for receiving messages from B),
B will store the message because it expects #1 from A (new connection). As a matter of fact, B will store *and not
deliver* all subsequent messages from A !

The reverse direction is also bad: B will send #1 to A, but A expects #7, so A will discard the message. The first 6
messages from B are discarded at A !


Goals
-----

#1 Handle the above scenarios

#2 Handle the scenario where a member communicates with a non-member

#3 Handle the scenario where a member talks to a non existing (or previous) member. Get rid of
   ENABLE_UNICASTS_TO and age out connections to non existing members after some time (JGRP-942)

#4 Should be usable without group communication ('Unicast JGroups')


Design
------

As example we have a unicast connection between A and B. A is the sender and B the receiver:

             A <-------------------------------------------------> B

             B:entry.seqno=#25                                     A:entry.seqno=#7
                     recv_win=#7                                           recv_win=#25
                     send-conn-id=322649                                   send-conn-id=101200
                     recv-conn-id=101200                                   recv-conn-id=322649

A has an entry in the connection table for B, and B has an entry for A. Each connection has a connection ID (conn-id).
Each entry also has a seqno which is the highest seqno sent to the peer so far, and a recv_win which has the highest
seqno received from the peer so far. For example, A's next message to B will be #25, and the next seqno expected
from B is #7.



A sends a message to B:
- If the entry for B is null, or the seqno=0:
    - Create an entry, set the seqno to 1 and set send-conn-id to the current time (needs to be unique, could also use UUIDs)
    - Add send-conn-id to the UnicastHeader and send the message
- Else
    - Send the message with the next seqno (and conn-id=0)

B receives a message from A:
- If conn-id != 0
    - If entry or entry.recv_win for B is null
        - Create a new entry.recv_win with msg.seqno
        - Set entry.recv-conn-id to conn-id
    - Else:
        - If conn-id == entry.recv-conn-id: NOP (prevents duplicate connection establishments)
        - Else
            - Create a new entry.recv_win with msg.seqno
            - Set entry.recv-conn-id to conn-id
- Else
    - If entry or entry.recv_win is null:
        - Discard message
        - Send GET_FIRST_SEQNO to A
    - Else
        - Add message to entry.recv_win


A receives GET_FIRST_SEQNO from B:
- A grabs the first message in its sent_win
- A adds the entry.send-conn-id to the UnicastHeader (if not yet present) and sends the message to B



Scenarios
---------

A creates new connection to B:

B receives new connection:

A and B close connection (e.g. based on a view change (partition))

A closes the connection unilaterally (B keeps it open), then reopens it and sends a message

B closes its connection unilaterally, then A sends a message to B

Merge where A and B are in different partitions

Merge where A and B are in overlapping partitions (A: {A}, B: {A,B} or A: {A,B}, B: {B})






Issues
------
- How do we handle retransmissions of the first message (first=true) ? We *cannot* create a new entry.recv_win, or
  else we trash already received msgs ! Use a UUID (as connection-ID) instead of first=true ? Maybe the system time
  is sufficient ? After all, the ID only has to be unique between A and B !
  ==> Solved by using connection IDs (see above)
  

